<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot 优雅的实现CORS跨域</title>
    <url>/springBoot/Spring%20Boot%20%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0CORS%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  一般的情况下，项目都是前后端分离的，所以这里就涉及到一个很严重的问题，当协议，端口，IP三者有其一不同就会产生跨域，所以需要做跨域支持。</p>
<a id="more"></a>
<h1 id="测试跨域的文件"><a href="#测试跨域的文件" class="headerlink" title="测试跨域的文件"></a>测试跨域的文件</h1><p>在这之前，我们先写一个测试接口是否跨域的html ,这样下面的测试比较方便。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;link type&#x3D;&quot;test&#x2F;css&quot; href&#x3D;&quot;css&#x2F;style.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;input type&#x3D;&quot;text&quot; style&#x3D;&quot;width:600px;height:30px;font-size:14px;&quot; id&#x3D;&quot;urlText&quot; value&#x3D;&quot;&quot; &#x2F;&gt;</span><br><span class="line">	&lt;br&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;button&quot; style&#x3D;&quot;margin: 10px&quot;;  id&#x3D;&quot;cors&quot; value&#x3D;&quot;判断是否可访问&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;http:&#x2F;&#x2F;localhost:9090&#x2F;test&#x2F;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;code.jquery.com&#x2F;jquery-3.2.1.min.js&quot;&gt;&lt;&#x2F;script&gt;  </span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	$(function()&#123;</span><br><span class="line">	$(&quot;#cors&quot;).click(</span><br><span class="line">		function()&#123;</span><br><span class="line">			var url2 &#x3D; $(&quot;#urlText&quot;).val();</span><br><span class="line">			$.post(&#123;</span><br><span class="line">				contentType:&#39;application&#x2F;x-www-form-urlencoded;charset&#x3D;UTF-8&#39;,</span><br><span class="line">				url:url2,</span><br><span class="line">				data: &quot;&#x2F;rAIeKeSBG1LV XoIq82&#x2F;O&quot;,</span><br><span class="line">				success:function(data)&#123;</span><br><span class="line">					alert(&quot;success&quot;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;)</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>接下来我们来学习下在springboot 项目中怎么实现支持跨域。</p>
<h1 id="CrossOrigin-注解"><a href="#CrossOrigin-注解" class="headerlink" title="@CrossOrigin 注解"></a>@CrossOrigin 注解</h1><p>这种方法是springboot 自带的，使用比较简单，在需要支持的跨域的接口上加上这个注解就可以了。<br>比如在我们项目的demo 接口加上注解.就表示这个接口支持跨域，其中origins = “*”<br>表示所有的地址都可以访问这个接口，也可以写具体的地址，表示只有这个地址访问才能访问到接口。<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@CrossOrigin(origin &#x3D;&quot;*&quot;)</span><br><span class="line">public class Demo &#123;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">	public String Demo() &#123;</span><br><span class="line">		return &quot;Hello Word&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>我们也来测试一下，启动项目后，在浏览器上运行我们的测试的html文件。<br>发现localhost:9090/test/ 是可以访问的。<br>说明跨域是支持的。大伙可以先将注解去掉测试一下，然后加上注解测试一下进行对比。</p>
<p>这种方式虽然很简单，但是缺点也不小，需要跨域的接口都需要加上这个注解，这对前后端分离的项目是不友好的，所以这种方式基本上用的很少。</p>
<h1 id="重写WebMvcConfigurer的addCorsMappings-方法。"><a href="#重写WebMvcConfigurer的addCorsMappings-方法。" class="headerlink" title="重写WebMvcConfigurer的addCorsMappings 方法。"></a>重写WebMvcConfigurer的addCorsMappings 方法。</h1><p>这种方法在实际项目中也用的比较多，是一种全局支持跨域的方法。<br>我们创建一个CorsConfig 类。内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class CorsConfig implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        registry.addMapping(&quot;&#x2F;**&quot;)&#x2F;&#x2F;项目中的所有接口都支持跨域</span><br><span class="line">                .allowedOrigins(&quot;*&quot;)&#x2F;&#x2F;所有地址都可以访问，也可以配置具体地址</span><br><span class="line">                .allowCredentials(true)</span><br><span class="line">                .allowedMethods(&quot;*&quot;)&#x2F;&#x2F;&quot;GET&quot;, &quot;HEAD&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;</span><br><span class="line">                .maxAge(3600);&#x2F;&#x2F; 跨域允许时间</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上@Configuration 表示是配置类，在项目启动的时候会加载。实现WebMvcConfigurer 接口并重写addCorsMappings 方法。代码比较简单，也有注释。</p>
<p>测试的话，大家可以自行测试，我测试都是通过的和上面一样测试就可以，这里就不占篇幅了。</p>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><p>除了上面方法外，也可以使用过滤器。我们创建一个CorsFilter 类，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@Component</span><br><span class="line">public class CorsFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletResponse response &#x3D; (HttpServletResponse)servletResponse;</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, PUT, GET, OPTIONS, DELETE&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Max-Age&quot;, &quot;3600&quot;);</span><br><span class="line">        response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept, client_id, uuid, Authorization&quot;);</span><br><span class="line">        response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache, no-store, must-revalidate&quot;);</span><br><span class="line">        response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);</span><br><span class="line">        filterChain.doFilter(servletRequest,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中设置response.setHeader(“Access-Control-Allow-Origin”, “*”);表示所有的地址都可以访问项目接口。</p>
<h1 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h1><p>接下来我们再介绍一个常用的功能，前后端分离，在访问接口的时候，有的 公司往往会增加一下专属的后缀名才能访问。实际上没有什么太大的作用，能稍微增加一下系统的安全性。这里我就简单是实现一下。真个都非常简单。<br>一样的是实现WebMvcConfigurer 接口，重写configurePathMatch你方法和增加一个dispatcherServlet。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void configurePathMatch(PathMatchConfigurer configurer) &#123;</span><br><span class="line">        configurer.setUseRegisteredSuffixPatternMatch(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean servletRegistrationBean(DispatcherServlet dispatcherServlet) &#123;</span><br><span class="line">        ServletRegistrationBean bean &#x3D; new ServletRegistrationBean(dispatcherServlet);</span><br><span class="line">        bean.addUrlMappings(&quot;*.zlf&quot;);</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这个功能实现，就只用这个多代码，configurePathMatch方法中设置的configurer.setUseRegisteredSuffixPatternMatch(true); 主要是将index 和index.* 都指向我们controller 中配置的@RequestMapping(“/index”)。</p>
<p>下面的servletRegistrationBean 方法主要是增加自定义拦截器，只有后缀为“.zlf”的接口才放行。</p>
<p>这样两步就简单的实现了接口增加自定义的后缀名了。</p>
<p>到此为止，springboot 支持跨域的方式就差不多了，当然还有其他的实现方式没有研究。这些希望对大家有帮助。</p>
]]></content>
      <categories>
        <category>springBoot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/hello-world/</url>
    <content><![CDATA[<p>谈谈建站之路…</p>
<a id="more"></a>
<h2 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h2><h3 id="坐井观天"><a href="#坐井观天" class="headerlink" title="坐井观天"></a>坐井观天</h3><p>&ensp;&ensp;转眼毕业已经半年有余，主要的工作状态就好像每天都很忙又感觉不知道自己在忙什么。眨眼一晃半年多就这么过来了，这段时间认识了很多很多人，经历了很多很多事，就像做梦一样。刚好这次赶上疫情(看到的你记得戴口罩，保护好自己)，在家的时间比较多，总结了一下:emm,生活真的好难，好像还是代码简单，那我想尽力把简单的事做好,不然连做自己都做不到，更没什么资格去承担什么责任。</p>
<h3 id="关于本站"><a href="#关于本站" class="headerlink" title="关于本站"></a>关于本站</h3><p>&ensp;&ensp;主要写一些自己在工作以及在平时学习上的总结，这段儿会陆续整理之前想总结一直没下手的,今天先简单整理了两个…不定时更新</p>
<h3 id="总得有个标题吧"><a href="#总得有个标题吧" class="headerlink" title="总得有个标题吧"></a>总得有个标题吧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello word , hello world！</span><br></pre></td></tr></table></figure>

<p><img src="/images/hello-word.jpg" alt="alt"></p>
]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>感悟</tag>
      </tags>
  </entry>
</search>
